-- 1. Create the PUBLIC 'assets' bucket
-- We set public = true so files can be accessed without a token (via the /public/ endpoint)
INSERT INTO storage.buckets (id, name, public) 
VALUES ('assets', 'assets', true);

-- 2. Create the PRIVATE 'vault' bucket
-- We set public = false so files require a Bearer token (which our Nginx proxy handles)
INSERT INTO storage.buckets (id, name, public) 
VALUES ('vault', 'vault', false);

-- Allow the whole world to view files in 'assets'
CREATE POLICY "Public Assets are viewable by everyone" 
ON storage.objects FOR SELECT 
USING ( bucket_id = 'assets' );

-- Allow logged-in users to upload to 'assets'
CREATE POLICY "Authenticated users can upload assets" 
ON storage.objects FOR INSERT 
WITH CHECK ( 
  bucket_id = 'assets' 
  AND auth.role() = 'authenticated' 
);

-- Allow users full access (Select, Insert, Update, Delete) ONLY to their own folder
CREATE POLICY "Users can manage their own vault files" 
ON storage.objects FOR ALL 
USING (
    bucket_id = 'vault' 
    AND auth.uid()::text = (storage.foldername(name))[1]
)
WITH CHECK (
    bucket_id = 'vault' 
    AND auth.uid()::text = (storage.foldername(name))[1]
);

-- =================================================================
-- 1. SETUP THE SHARING TABLE
-- =================================================================

-- Create a table to track permissions
-- This lives in the 'public' schema so your app can query it easily
create table if not exists public.file_shares (
  id bigint generated by default as identity primary key,
  file_path text not null,                       -- e.g. 'user-123/map_hash.png'
  owner_id uuid references auth.users not null,  -- The user who owns the file
  shared_with_user_id uuid references auth.users not null, -- The user getting access
  created_at timestamptz default now()
);

-- Create an index to make permission checks instant
-- (Crucial because this runs on every file download)
create index if not exists idx_file_shares_path_user 
on public.file_shares(file_path, shared_with_user_id);

-- Enable RLS on the sharing table itself
alter table public.file_shares enable row level security;

-- Policy: Users can see shares they own OR shares meant for them
create policy "Users can view relevant shares"
on public.file_shares for select
using ( owner_id = auth.uid() or shared_with_user_id = auth.uid() );

-- Policy: Only the owner can CREATE or DELETE shares
create policy "Owners manage their shares"
on public.file_shares for all
using ( owner_id = auth.uid() )
with check ( owner_id = auth.uid() );


-- =================================================================
-- 2. UPDATE STORAGE POLICIES
-- =================================================================

-- First, drop the old blanket policy for the vault bucket
-- (This assumes you ran the previous setup; if not, this line might fail safely)
drop policy if exists "Users can manage their own vault files" on storage.objects;

-- -----------------------------------------------------------------
-- Policy A: WRITE ACCESS (Insert, Update, Delete)
-- STRICT: Only the user who owns the folder can modify files.
-- -----------------------------------------------------------------
create policy "Vault Write Access (Owner Only)" 
on storage.objects for insert 
with check (
  bucket_id = 'vault' 
  and auth.uid()::text = (storage.foldername(name))[1]
);

-- We need separate policies for Update/Delete to be safe
create policy "Vault Update Access (Owner Only)" 
on storage.objects for update
using (
  bucket_id = 'vault' 
  and auth.uid()::text = (storage.foldername(name))[1]
);

create policy "Vault Delete Access (Owner Only)" 
on storage.objects for delete
using (
  bucket_id = 'vault' 
  and auth.uid()::text = (storage.foldername(name))[1]
);

-- -----------------------------------------------------------------
-- Policy B: READ ACCESS (Select)
-- HYBRID: You can see the file IF:
-- 1. You own the folder OR
-- 2. There is a row in 'public.file_shares' granting you access.
-- -----------------------------------------------------------------
create policy "Vault Read Access (Owner or Shared)" 
on storage.objects for select 
using (
  bucket_id = 'vault'
  and (
    -- Option 1: It is your own file
    auth.uid()::text = (storage.foldername(name))[1]
    
    OR
    
    -- Option 2: It has been shared with you in the DB
    exists (
      select 1 
      from public.file_shares fs 
      where fs.file_path = storage.objects.name -- Matches 'user-123/image.png'
      and fs.shared_with_user_id = auth.uid()
    )
  )
);